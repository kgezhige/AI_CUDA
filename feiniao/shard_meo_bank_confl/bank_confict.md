### bank conflict
在CUDA中，当将全局内存的32个元素搬运到共享内存的前两列（列0和列1）时，若线程映射方式为前16个线程（线程0-15）写入列0，后16个线程（线程16-31）写入列1，则会引发严重的bank冲突。具体分析如下：

---

1. **共享内存的Bank机制**
• CUDA共享内存被划分为32个bank（假设设备计算能力≥2.0），每个bank的宽度为4字节。

• Bank冲突：当同一warp中的多个线程访问同一bank的不同地址时，访问会被序列化，导致性能下降。

• 地址到bank的映射：`bank_index = (address_in_shared_memory) % 32`。


---

2. **访问模式分析**
假设共享内存为`float sdata[16][16]`，每个线程的写入位置如下：
• 线程0-15：写入列0，行号为`t`（`sdata[t][0]`），地址为 `t * 16`。

• 线程16-31：写入列1，行号为`t-16`（`sdata[t-16][1]`），地址为 `(t-16) * 16 + 1`。


**Bank计算**
• 列0的地址（线程0-15）：

  • 地址为 `t * 16`，对应 `bank = (t * 16) % 32`。

  • 当`t`为偶数时，bank为0；当`t`为奇数时，bank为16。

  • 结果：前16个线程中，8个线程访问bank0，8个访问bank16。

  
• 列1的地址（线程16-31）：

  • 地址为 `(t-16) * 16 + 1`，对应 `bank = ((t-16) * 16 + 1) % 32`。

  • 当`t-16`为偶数时，bank为1；当`t-16`为奇数时，bank为17。

  • 结果：后16个线程中，8个线程访问bank1，8个访问bank17。


---

3. **Bank冲突分析**
• Bank0和Bank16：各被8个线程访问不同地址，导致8-way冲突。

• Bank1和Bank17：同理，各被8个线程访问不同地址，导致8-way冲突。

• 总影响：每个bank的访问需要8个周期（理想无冲突时为1周期），整体访问时间延长8倍。
 所以有 8-1=7路冲突。 


---

4. **优化建议**
**方案1：调整数据布局**
• Padding（填充列）：将共享内存定义为`sdata[16][17]`（多一列），使相邻行的列元素地址步长变为17（与32互质），从而分散bank访问。

  ```cpp
  __shared__ float sdata[16][17]; // 填充一列
  ```
  • 写入列0的地址变为 `t * 17`，bank分布更均匀，避免冲突。


**方案2：调整线程映射**
• 交错访问：将线程映射为按行交替写入不同列，例如：

  • 偶数线程写入列0，奇数线程写入列1。

  • 确保相邻线程访问不同bank，减少冲突。


**方案3：合并访问**
• 向量化加载：使用`float2`或`float4`类型一次性读取连续内存，减少访问次数并改善bank利用率。


---

5. **关键结论**
• 当前映射方式存在严重8-way bank冲突，导致性能显著下降。

• 优化核心：通过调整数据布局或线程映射，使同一warp内的线程访问不同bank，或减少同一bank的并发访问次数。


通过上述优化，可显著降低bank冲突，提升共享内存访问效率。